#!python3

# ASGI acts as either synchronous or asynchronous web application standard
# uvicorn is a lightweight, high-performance ASGI server

from fastapi import FastAPI
from fastapi import Query
from pydantic import BaseModel
from typing import List
import app.etl.extract as extract
import app.etl.transform as transform
import app.etl.load as load
import app.etl.plot as plot

MIN_WINDOW = 7
MAX_WINDOW = 252
DEFAULT_WINDOW = 30

app = FastAPI()

class Portfolio(BaseModel):
    owner: str
    holdings: List[str]

@app.get("/")
def read_root():
    return {"message": "Welcome to MarketFlow ETL API"}

@app.get("/etl/{symbol}")
def get_etl(symbol: str, window: int = Query(DEFAULT_WINDOW, ge=MIN_WINDOW, le=MAX_WINDOW)): #window is bounded between 1 and 60
    df = extract.get_historical_data(symbol)
    df = transform.add_moving_average(df, window)
    df = transform.add_volatility(df, window)
    file_path = load.save_to_csv(df, symbol)
    load.save_to_db(df, symbol)
    load.save_parquet_with_spark(df, symbol)
    plot.plot_indicators(df, symbol)

    return {
        "message": f"ETL complete for {symbol}",
        "data_points": len(df),
        "saved_to": file_path
    }

# Health Check
@app.get("/health")
def get_health():
    return 0

# Get key metrics for a given symbol (e.g., AAPL)
@app.get("/metrics/{symbol}")
def get_metrics(symbol: str):
    return {
        "symbol": symbol.upper(),
        "message": f"Basic placeholder metrics for {symbol.upper()}"
    }

# Compute and return moving average
@app.get("/moving-average/{symbol}?window=30")
def get_moving_average(symbol: str):
    return 0

# Return rolling volatility over time
# Volatility - How much a stock's price fluctuates
# Rolling Volatility - standard deviation (spread of data) of log returns over a window of a stock's fluctuation
# For annualized: rolling_vol = log_returns.rolling(window=20).std() * np.sqrt(252)
# - 252 trading days in a year
# A log return (or logarithmic return) measures the percentage change in price between two time periods, 
# but it does so using natural logarithms instead of simple arithmetic.
# log_returns = np.log(df["Close"] / df["Close"].shift(1))
# - today's close over yesterday's close
# - Simple return = (110 - 100)/100 = 0.10 -> 10%
# - Log return = ln(110/100) = ~ 0.0953 -> 9.53%, measure relative change not raw change
# -- Log return is mathematically additive, meaning you can sum log returns over time to get the total log return
# Loads a PNG line plot
@app.get("/volatility/{symbol}")
def get_volatility(symbol: str, window: int = Query(DEFAULT_WINDOW, ge=MIN_WINDOW, le=MAX_WINDOW),
                    annualized: bool = False):
    df = extract.get_historical_data(symbol)
    df = transform.add_volatility(df, window, annualized)

    file_path = plot.plot_rolling_volatility(df, symbol, window, annualized)

    return {
        "message": f"Generating rolling volatility for {symbol}",
        "window": window,
        "image_path": file_path,
        "data": [
            {
                "date": str(date),
                "volatility": round(vol, 6) if vol == vol else None 
            }
            for date, vol in zip(df["Date"], df["Volatility"])
        ]

    }


# Compute and return correlation matrix
@app.get("/correlation?symbols=AAPL,MSFT,GOOGL")
def get_correlation_matrix():
    return 0

# Sharpe ratio based on the last 90 days

# Sharpe ratio is a financial metric that measures an investment's performance while considering its 
# associated risk. In essence, it tells investors whether the excess return generated by an investment 
# is adequate compensation for the additional risk they've undertaken compared to a risk-free investmen

# Formula: Sharpe Ratio = (Rp - Rf) / Standard Deviation
# Rp: The investment's rate of return (either historical or expected).
# Rf: The risk-free rate of return, typically represented by a short-term US Treasury bond yield 
#     or the cash rate.
# Standard Deviation: A measure of the investment's volatility or risk, indicating how much its 
#                     returns fluctuate around the average return. 

@app.get("/sharpe-ratio/{symbol}")
def get_sharpe_ratio(symbol: str):
    return 0

# Return a chart of price + moving averages
@app.get("/chart/{symbol}")
def get_chart(symbol: str):
    return 0

@app.post("/portfolio")
def summarize_portfolio(portfolio: Portfolio):
    num_holdings = len(portfolio.holdings)
    return {
        "message": f"Portfolio received for {portfolio.owner}",
        "num_stocks": num_holdings,
        "tickers": portfolio.holdings
    }
